#!/bin/bash

version=1.0.6
real_portable_folder="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$real_portable_folder"
# Log file.
exec > >(tee log.txt) 2>&1
# Load common functions.
source bin/ios_funcs

echo -e "A999 Activator (A9, iOS 9, 9 years later) v$version\n(C) 2025 Alex Free (3-BSD)\nhttps://github.com/alex-free/a999activator\n"

# Global vars.
os="$(uname)"
arch="$(uname -m)"
device=
# If false A10.
a9=false
ver=
serial=
not_normal=false
ipsw_file=
# Used to check if we need iOS 15 to be restored to get activation files, it doubles as a disable to prevent a recursive infinite loop when calling the restore_ipsw() func as well.
restore_signed_ios=false
# Need to do more steps for final restore.
not_final_restore=true

# OS/arch detection.
# Add all the self-contained binaries we need to the $PATH used within this script.

if [ "$os" = "Linux" ]; then

    if [ "$arch" = "x86_64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/x86_64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-amd64/bin"
    elif [ "$arch" = "arm64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/arm64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-arm64/bin"
    else
        echo "Error: Linux on $arch is not supported."
        exit 1
    fi

    echo "Detected Linux on $arch."

elif [[ "$os" == "Darwin" ]]; then
    PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/macos:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_macos/bin"
    echo "Detected Mac OS on $arch."
else
    echo "Error: $os is not supported."
    exit 1
fi

echo "PATH: $PATH"

iproxy_start() {
    iproxy 6414 22 > /dev/null 2>&1 &
}

iproxy_kill() {
    killall iproxy > /dev/null 2>&1
}

did_you_follow_instructions() {
    pair_iphone
    read -p "* Activate the iPhone. IMPORTANT: If you are going to use cellular features on iOS 9, your SIM card should be in the iPhone with an active carrier. 

* Sign in to iCloud and complete Setup.app. Get to the home screen. 

* Make sure Find My iPhone has been turned off.

After all of the above is true press any key to continue..."
    wait_for_activation
}

is_activated() {

    if ideviceinfo | grep -q "^ActivationState: Activated$"; then
        return 0
    else
        return 1
    fi
}

start_rd() {
    # Enfore Recovery Mode.
    enter_recovery
    ssh_connected=0

    while [[ $ssh_connected != 1 ]]; do
        # Incase this failed previously and is running again, wait.
        wait_for_recovery
        # Stay in Recovery Mode, prevent normal mode booting until ramdisk boots and runs script to restore this. Unless we enter DFU mode accidentally this is the most useful case of enforce_recovery ever.
        enforce_recovery
        # Clear any existing iproxy...
        iproxy_kill
        # Attempt to boot ramdisk...
        (cd bin/Legacy-iOS-Kit && ./restore.sh --no-version-check --no-internet-check --sshrd-boot-rd-only)
        # Restart after ramdisk script kills our usbmuxd.
        usbmuxd_reset   
        # Start our own proxy for USB SSH fresh...
        iproxy_kill
        iproxy_start
        echo "Waiting 5 seconds before testing SSH ramdisk connection, please standby..."
        sleep 5
        # SSH connection check.
        ssh_connected=$(sshpass -p 'alpine' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1 'echo 1' 2>/dev/null)
    done

    # Need to reset this for ramdisk round 2.
    ssh_connected=0

    echo "Booted SSH Ramdisk!"

    #ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
}

wait_for_activation()
{
    # This confirms the iPhone is activated. It does not confirm if iCloud was signed in, if Find My iPhone was turned off, or if an active cell service SIM was used during activation.
    while ! is_activated; do
        read -p "iPhone is not activated! Please make sure all of the above criteria are true as well and then press enter."
        sleep 1
    done
}

got_all_activation_files() {
    if [[ -f data/$device-$serial/activate/activation_records.tar.gz && \
          -f data/$device-$serial/activate/data_ark.plist.tar.gz && \
          -f data/$device-$serial/activate/IC-Info.sisv.tar.gz && \
          -f data/$device-$serial/activate/com.apple.commcenter.device_specific_nobackup.plist.tar.gz && \
          -f data/$device-$serial/activate/com.apple.factorydata.tar.gz ]]; then
        return 0
    else
        return 1
    fi
}

get_activation() {
    # Need to get activation files.
    echo -e "Existing activation files not backed up yet.\nObtaining activation files..."
    # Hail Mary if on latest iOS 15 already.
    ios_version=$(ideviceinfo 2>/dev/null | grep "ProductVersion" | awk '{print $2}')

    # Set $not_normal when first connecting/detecting iPhone if it is in Recovery or DFU Mode.
    if [ "$not_normal" == "true" ]; then
        echo "Your iPhone is not in normal mode, so iOS version can not be determined. Restoring iPhone to iOS 15.8.5."
        restore_signed_ios=true
    elif [ "$ios_version" != "15.8.5" ]; then
        echo "Latest iOS version is not installed. Restoring iPhone to iOS 15.8.5."
        restore_signed_ios=true
    elif [ "$ios_version" == "15.8.5" ]; then
        did_you_follow_instructions
    fi

    if [ "$restore_signed_ios" == "true" ]; then
        restore_signed_ios_for_device
    fi

    # Makes sure we don't stop until we actually get the activation files.
    while ! got_all_activation_files; do
        # Send it...
        start_rd

        expect <<EOF
        # Mount.
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
        expect {
            "continue connecting" {
                send "yes\r"
                exp_continue
            }
            "password:" {
                send "alpine\r"
            }
        }

        expect "#"
        send "mount_filesystems\r"
        expect "#"
        
        # Ramdisk allows RW of / on unjailbroken iOS 15.8.5. on /private/var we have stable RO. RW sometimes doesn't work, so use / as scratch dir.
        send "mkdir /mnt1/activate\r"
        expect "#"
        
        # Copy activation_records.
        send "cp -a /mnt2/containers/Data/System/*/Library/activation_records /mnt1/activate/activation_records\r"
        expect "#"

        # Copy data_ark.plist.
        send "cp -a /mnt2/containers/Data/System/*/Library/activation_records/../internal/data_ark.plist /mnt1/activate\r"
        expect "#"

        # Copy IC-Info.sisv for notifications/ft/imessage/etc
        send "cp -a /mnt2/mobile/Library/FairPlay/iTunes_Control/iTunes/IC-Info.sisv /mnt1/activate\r"
        expect "#"

        # Copy com.apple.commcenter.device_specific_nobackup.plist
        send "cp -a /mnt2/wireless/Library/Preferences/com.apple.commcenter.device_specific_nobackup.plist /mnt1/activate\r"
        expect "#"
        
        # Copy com.apple.factorydata
        send "cp -a /mnt1/System/Library/Caches/com.apple.factorydata /mnt1/activate/com.apple.factorydata\r"
        expect "#"

        # Create tars.
        send "cd /mnt1/activate\r"
        expect "#"
        
        # activation_records.
        send "tar zcf activation_records.tar.gz activation_records\r"
        expect "#"

        # data_ark.plist.
        send "tar zcf data_ark.plist.tar.gz data_ark.plist\r"
        expect "#"
        send "rm data_ark.plist\r"
        expect "#"
        
        # IC-Info.sisv. 
        # Silence error: "tar: copyfile pack (IC-Info.sisv) failed: No such file or directory" because we still get the file fine.
        send "tar zcf IC-Info.sisv.tar.gz IC-Info.sisv > /dev/null 2>&1\r"
        expect "#"
        send "rm IC-Info.sisv\r"
        expect "#"

        # com.apple.commcenter.device_specific_nobackup.plist.
        send "tar zcf com.apple.commcenter.device_specific_nobackup.plist.tar.gz com.apple.commcenter.device_specific_nobackup.plist\r"
        expect "#"
        send "rm com.apple.commcenter.device_specific_nobackup.plist\r"
        expect "#"

        # com.apple.factorydata.
        send "tar zcf com.apple.factorydata.tar.gz com.apple.factorydata\r"
        expect "#"

        # Delete all directories.
        send "rm -rf */\r"
        expect "#"

        send "exit\r"

        # Transfer tars to computer.
        spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r -P 6414 root@127.0.0.1:/mnt1/activate data/$device-$serial
        expect {
            "continue connecting" {
                send "yes\r"
                exp_continue
            }
            "password:" {
                send "alpine\r"
            }
        }
        expect eof  

        # Unmount and Reboot.
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
        expect {
            "continue connecting" {
                send "yes\r"
                exp_continue
            }
            "password:" {
                send "alpine\r"
            }
        }

        expect "#"
        send "reboot\r"
        expect "closed by remote host."
        expect eof
EOF

        iproxy_kill

        # Check to see if user follows instructions.  If not when we get back to restore_ipsw() it will prompt to go through get_activation() again.
        if ! got_all_activation_files; then
            echo "Error: not all activation files were backed up. Please make sure you complete all steps before activation files are backed up. A999 Activator will try getting activation files again."
            read -p "Press any key to continue..."
        fi
    done
}

downgrade() {    
    # Get Activation files.
    while ! got_all_activation_files; do
        get_activation
    done

    restore_ios_10_2_1_for_device
    # Enable all steps for final restore.
    not_final_restore=false
    restore_ipsw $1
    start_rd

    expect <<EOF
    # Set up /.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "mount_hfs /dev/disk0s1s1 /mnt1\r"
    expect "#"
    send "mount_hfs /dev/disk0s1s2 /mnt2\r"
    expect "#"
    send "rm -rf /mnt1/activation\r"
    expect "#"
    send "mkdir /mnt1/Library/LaunchDaemons\r"
    expect "#"
    send "exit\r"

    # Transfer activation tars to phone.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r -P 6414 data/$device-$serial/activate root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer launch daemon com.alex.activate.plist to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 payload/com.alex.activate.plist root@127.0.0.1:/mnt1/Library/LaunchDaemons
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer activate script to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 payload/activate root@127.0.0.1:/mnt1/usr/bin
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer freeze.tar to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 bin/Legacy-iOS-Kit/resources/jailbreak/freeze.tar root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer launchctl.tar to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 bin/Legacy-iOS-Kit/resources/jailbreak/launchctl.tar root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer io.pangu93.loader.plist to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 bin/Legacy-iOS-Kit/resources/jailbreak/io.pangu93.loader.plist root@127.0.0.1:/mnt1/Library/LaunchDaemons
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer plutil (from com.bingner.plutil_0.2.1_iphoneos-arm.deb) to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 payload/plutil root@127.0.0.1:/mnt1/usr/bin/plutil
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"

    # Set permissions for activate.
    send "chmod 755 /mnt1/usr/bin/activate\r"
    expect "#"
    send "chown root:wheel /mnt1/usr/bin/activate\r"
    expect "#"

    # Set permissions for plutil.
    send "chmod 755 /mnt1/usr/bin/plutil\r"
    expect "#"
    send "chown root:wheel /mnt1/usr/bin/plutil\r"
    expect "#"

    # Install chflags from ramdisk
    send "cp -a /usr/bin/chflags /mnt1/usr/bin/chflags\r"
    expect "#"

    # Set permissions for launch daemon com.alex.activate.plist.
    expect "#"
    send "chmod 644 /mnt1/Library/LaunchDaemons/com.alex.activate.plist\r"
    expect "#"
    send "chown root:wheel /mnt1/Library/LaunchDaemons/com.alex.activate.plist\r"
    expect "#"
    
    # Move Setup.app to prevent possible deactivation causing it to trigger.
    send "mv /mnt1/Applications/Setup.app /mnt1/Applications/Setup.bak\r"
    expect "#"
    
    # BEGIN JAILBREAK BOOTSTRAP INSTALLATION.
    # Set permissions for launch daemon io.pangu93.loader.plist.
    send "chmod 644 /mnt1/Library/LaunchDaemons/io.pangu93.loader.plist \r"
    expect "#"
    send "chown root:wheel /mnt1/Library/LaunchDaemons/io.pangu93.loader.plist\r"
    expect "#"

    send "cd /mnt1\r"
    expect "#"

    # Extract freeze.tar.
    send "tar -xf freeze.tar -C .\r"
    expect "#"
    send "rm freeze.tar\r"
    expect "#"

    # Extract launchctl.tar.
    send "tar -xf launchctl.tar -C .\r"
    expect "#"
    send "rm launchctl.tar\r"
    expect "#"

    # Is this the symlink trick to write to /var?) 
    send "mv private/var/lib private\r"
    expect "#"
    send "mv private/var/mobile/Library/Preferences/com.apple.springboard.plist private\r"
    expect "#"
    send "rm -r private/var/*\r"
    expect "#"
    send "touch .cydia_no_stash\r"
    expect "#"
    send "cd /mnt2\r"
    expect "#"
    send "ln -s /private/lib\r"
    expect "#"
    send "cd mobile/Library/Preferences\r"
    expect "#"
    send "rm -f com.apple.springboard.plist\r"
    expect "#"
    send "ln -s /private/com.apple.springboard.plist\r"
    expect "#"
    send "chown 501:501 com.apple.springboard.plist\r"
    expect "#"
    send "exit\r"

    # Unmount and Reboot. Spawn a new session because symlink trick is weird and prevents unmounting /mnt2.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "umount /mnt1\r"
    expect "#"
    send "umount /mnt2\r"
    expect "#"
    send "reboot\r"
    expect "closed by remote host."
    expect eof
EOF

    iproxy_kill
    boot_turdusra1n
    
    echo "Your iPhone is now jailbroken! You need to enable it now by visiting http://jbme.ddw.nu/ in Safari after signing in to your WiFi. Once the jailbreak is enabled, your iPhone will automatically reboot into Recovery Mode after restoring activation. Do not sign in to iCloud just yet! a999activator is going to start checking for Recovery Mode in 45 seconds so that the LAST STEP can be completed!"
    sleep 45

    boot_turdusra1n

    if [ $device == "iphone-6s-plus" ]; then
        boot_script=boot6sp-$ver-$serial
    elif [ $device == "iphone-6s" ]; then      
        boot_script=boot6s-$ver-$serial
    elif [ $device == "iphone-se" ]; then
        boot_script=bootse-$ver-$serial
    fi

    # Delete any existing boot* scripts for this serial number.
    rm -f *-$serial
    
    # Generate boot* script
    echo -e '#!/bin/bash

os="$(uname)"
arch="$(uname -m)"

# OS/arch detection.
# Add all the self-contained binaries we need to the $PATH used within this script.
real_portable_folder="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [ "$os" = "Linux" ]; then
    
    if [ "$arch" = "x86_64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/x86_64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-amd64/bin"
    elif [ "$arch" = "arm64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/arm64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-arm64/bin"
    else
        echo "Error: Linux on $arch is not supported."
        exit 1
    fi

    echo "Detected Linux on $arch."

elif [ "$os" == "Darwin" ]; then
    PATH="${PATH:+$PATH:}$real_portable_folder/bin/Legacy-iOS-Kit/bin/macos:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_macos/bin"
    echo "Detected Mac OS on $arch."
else
    echo "Error: $os is not supported."
    exit 1
fi

echo "PATH: $PATH"
cd "$real_portable_folder"

usbmuxd_reset() {
    if [ "$os" = "Linux" ]; then
        systemctl stop usbmuxd > /dev/null 2>&1
        # If usbmuxd is still running kill it forcibly.
        killall -9 usbmuxd > /dev/null 2>&1
        usbmuxd -f -p > /dev/null 2>&1 &
    fi
}

if [ "$os" = "Linux" ]; then

    if [ "$EUID" -ne 0 ]; then
        echo "Error: root privileges are required to boot your iPhone. Please execute $0 with sudo or as root to continue." >&2
        exit 1
    fi

    usbmuxd_reset
fi

# When this script exits, automatically restart usbmuxd as normal. We are root at this point that this takes effect (on Linux).
cleanup() 
{
    if [ "$os" = "Linux" ]; then 
        usbmuxd_reset
    fi
}
trap cleanup EXIT

# Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus.
while irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
    usbmuxd_reset
    echo "If you get an error about failed to open handle (no device) after Checkmate?, disconnect then reconnect your iPhone."

    while ! turdusra1n -TP data/'$device'-'$serial'/'$ver'/block/*-pteblock2.bin; do 
        usbmuxd_reset
        echo "Something went wrong, lets try that again..."
    done

    echo "Please wait, checking for proper booting in 20 seconds"
    sleep 20
done

echo "Enable the jailbreak with http://jbme.ddw.nu in Safari!"

' > $boot_script

    chmod 755 $boot_script
    # Clips the last character otherwise in the echo below.
    boot_script=$(echo "$boot_script" | tr -d '\r')
    echo "Activation was restored! You need to enable the jailbreak with http://jbme.ddw.nu in Safari everytime you boot, but your done! If your phone is powered off or rebooted, it will first boot to Recovery Mode. You'll need to run the $boot_script command (now found in the same folder as the a999 command) to boot it into normal mode."

    case "$ver" in
        9.2*)
            echo "IMPORTANT INFORMATION FOR iOS 9.2 AND iOS 9.2.1 USERS (WHICH YOU ARE): DO NOT SIGN IN TO ICLOUD IN SETUP.APP! It will not work. Instead, complete Setup.app without signing in and get to the home screen. Then, sign in to iCloud with the Settings app!"
            ;;
        9.3*)
            echo "IMPORTANT INFORMATION FOR iOS 9.3, iOS 9.3.1, iOS 9.3.2, AND iOS 9.3.3 USERS (WHICH YOU ARE): iMessage and FaceTime do not work yet!"
            if [ $device != "iphone-se" ]; then
                echo "If you need iMessage and or FaceTime downgrade to iOS 9.2 or iOS 9.2.1 instead."
            fi
            ;;
    esac

    echo -e "\nDONE!\n"
}

iphone_6s_firmware_select() {
    PS3="Select iOS version to downgrade to: "
    options=(
        "9.2 (13C75) (12/8/2015)"
        "9.2.1 (13D15) (1/19/2016)"
        #"9.2.1 (13D20) (2/18/2016)" Can't use because jbme doesn't support it
        "9.3 (13E234) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.2 (13C75) (12/8/2015)")
                downgrade http://appldnld.apple.com/ios9.2/031-29220-20151203-557E81AA-8D8B-11E5-BEE6-AD638B8BECEB/iPhone8,1_9.2_13C75_Restore.ipsw
                break;
                ;;
            "9.2.1 (13D15) (1/19/2016)")
                downgrade http://appldnld.apple.com/ios9.2.1/031-47635-20160119-97350056-B969-11E5-A65F-634D8FD31F8F/iPhone8,1_9.2.1_13D15_Restore.ipsw
                break;
                ;;
            #"9.2.1 (13D20) (2/18/2016)") Can't use because jbme doesn't support it
                #downgrade http://appldnld.apple.com/ios9.2.1/031-49377-20160217-4BB1908C-D44D-11E5-9900-0952919DCAD8/iPhone8,1_9.2.1_13D20_Restore.ipsw
                #break;
                #;;
            "9.3 (13E234) (3/21/2016)")
                downgrade http://appldnld.apple.com/iOS9.3/031-20814-20160321-50FF38D4-EAA8-11E5-AAA8-C479BD379832/iPhone8,1_9.3_13E234_Restore.ipsw
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.1/031-55114-20160331-09A05894-F5E6-11E5-861F-21CB2D794EB1/iPhone8,1_9.3.1_13E238_Restore.ipsw
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                downgrade http://appldnld.apple.com/ios9.3.2/031-62431-20160516-5E51F038-13A9-11E6-ACFA-61D9400DF7EB/iPhone8,1_9.3.2_13F69_Restore.ipsw
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.3/031-60536-20160718-06EE469E-4378-11E6-8185-A7F759E0E9B6/iPhone8,1_9.3.3_13G34_Restore.ipsw
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}


iphone_6s_plus_firmware_select() {

    PS3="Select iOS version to downgrade to: "
    options=(
        "9.2 (13C75) (12/8/2015)"
        "9.2.1 (13D15) (1/19/2016)"
        #"9.2.1 (13D20) (2/18/2016)" can't use because jbme doesn't support it
        "9.3 (13E234) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.2 (13C75) (12/8/2015)")
                downgrade http://appldnld.apple.com/ios9.2/031-29142-20151203-53B314A8-8D8B-11E5-B7FA-9A638B8BECEB/iPhone8,2_9.2_13C75_Restore.ipsw
                break;
                ;;
            "9.2.1 (13D15) (1/19/2016)")
                downgrade http://appldnld.apple.com/ios9.2.1/031-47609-20160119-798F784C-B969-11E5-8729-F24C8FD31F8F/iPhone8,2_9.2.1_13D15_Restore.ipsw
                break;
                ;;
            #"9.2.1 (13D20) (2/18/2016)") can't use because jbme doesn't support it
                #downgrade http://appldnld.apple.com/ios9.2.1/031-49073-20160217-4BB05046-D44D-11E5-9D30-0852919DCAD8/iPhone8,2_9.2.1_13D20_Restore.ipsw
                #break;
                #;;
            "9.3 (13E234) (3/21/2016)")
                downgrade http://appldnld.apple.com/iOS9.3/031-28376-20160321-51006FEC-EAA8-11E5-AEC6-D279BD379832/iPhone8,2_9.3_13E234_Restore.ipsw
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.1/031-54811-20160331-099896CC-F5E6-11E5-88BA-1ACB2D794EB1/iPhone8,2_9.3.1_13E238_Restore.ipsw
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                downgrade http://appldnld.apple.com/ios9.3.2/031-62657-20160516-02ECC2F8-13AA-11E6-AFB3-D9DA400DF7EB/iPhone8,2_9.3.2_13F69_Restore.ipsw
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.3/031-60985-20160718-5C7A1B06-4378-11E6-8743-CEFC59E0E9B6/iPhone8,2_9.3.3_13G34_Restore.ipsw
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}

iphone_se_firmware_select() {

    PS3="Select iOS version to downgrade to: "
    options=(
        "9.3 (13E232) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.3 (13E233) (3/21/2016)")
                downgrade http://appldnld.apple.com/iOS9.3/031-20815-20160321-5102B932-EAA8-11E5-A488-C779BD379832/iPhone8,4_9.3_13E233_Restore.ipsw
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.1/031-55507-20160331-09A917D6-F5E6-11E5-BFDA-32CB2D794EB1/iPhone8,4_9.3.1_13E238_Restore.ipsw
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                downgrade http://appldnld.apple.com/ios9.3.2/031-61688-20160516-6A0F5782-13A7-11E6-93C9-A4D6400DF7EB/iPhone8,4_9.3.2_13F69_Restore.ipsw
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                downgrade http://appldnld.apple.com/iOS9.3.3/031-60143-20160718-06E90A30-4378-11E6-81DC-8EF759E0E9B6/iPhone8,4_9.3.3_13G34_Restore.ipsw
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}

# Begin actual execution. 

if [ "$os" = "Linux" ]; then

    # On Linux we need root.
    if [ "$EUID" -ne 0 ]; then
        echo "Error: a999 must be ran with root privileges on Linux. Please execute it with sudo or as the root user to continue."
        exit 1
    fi

    # https://github.com/alex-free/a999activator/issues/8#issuecomment-3383734504
    if command -v dnf >/dev/null; then
        # Crypto libraries for lockdown.
        update-crypto-policies --set LEGACY > /dev/null 2>&1
        echo "Info, if you have a999 activator can not connect to your iPhone try rebooting your computer."
        # Set SE linux to permissive (resets on Reboot)
        setenforce 0
        # Deps.
        dnf install -y libimobiledevice libimobiledevice-utils expect idevicerestore irecovery
    elif command -v apt >/dev/null; then
        apt install --yes expect libimobiledevice libimobiledevice-utils expect idevicerestore irecovery
    fi
elif [ "$os" = "Darwin" ]; then
    # All these executables are signed so that is the only think preventing gatekeeper from allowing the script to be automatic is the quarintine attributes.
    # Remove any quarintine attributes in this folder.
    xattr -rc .
else
    echo "Error: unsupported operating system!"
    exit 1
fi

# When this script exits, automatically restart usbmuxd as normal. We are root at this point that this takes effect (on Linux).
cleanup() 
{
    if [ "$os" = "Linux" ]; then 
        usbmuxd_reset
    fi
}
trap cleanup EXIT

# Check for the existence of the binary launch daemon which is generated for the release by the build script.
if [ ! -f "payload/com.alex.activate.plist" ]; then
    echo "Error: can not find payload/com.alex.activate.plist. This most likely means you are trying to execute a999 from the source tree, rather then a release which is not allowed. Please execute the build command in the source tree and cd into the built release. If you downloaded an a999activator release and are getting this error, you release is incomplete and missing a neccesary file. Please redownload the release and run a999activator again."
    exit 1
fi

# Update functionallity. We need to get 2 things, the data folder and any boot* scripts.

if [ "$1" == "-u" ]; then

    if [ "$#" -ne 2 ]; then
        echo "You gave the -u argument, which expect an existing a999activator release directory as the following argument."
        exit 1
    fi

    if [ -d "$2"/data ]; then
        echo "Found existing data folder!"
        cp -rv "$2"/data .
        echo "Copied existing data folder to a999activator!"
    else
        echo "Error: Could not find the data folder in $2!"
        exit 1
    fi

    # Don't print error messages if no boot-* files exist.
    cp -rv "$2"/boot-* . 2>/dev/null 
    exit 0
fi

if [ ! -d data ]; then
    echo "Creating data folder..."
    mkdir data
else
    echo "Loaded existing data folder!"
fi

# Create ipsw directory if it does not exist.
mkdir -p data/ipsw

if [ ! -f "bin/Legacy-iOS-Kit/resources/firstrun" ]; then
    echo "Installing dependencies..."

    (cd bin/Legacy-iOS-Kit && ./restore.sh --no-version-check --no-internet-check)
    # This is to account for LibUSB being just installed.

    echo -e "Please do the following to ensure A999 Activator can talk to your iPhone:\n\n* Disconnect your USB-A Lightning cable from your mac.\n* Connect the USB-A Lightning cable to the Mac wih your iPhone connected.\n"

    read -p "After doing the above, press any key to continue..."
fi

detect_iphone

if [ $device == "iphone-6s-plus" ]; then
    iphone_6s_plus_firmware_select
elif [ $device == "iphone-6s" ]; then
    iphone_6s_firmware_select
elif [ $device == "iphone-se" ]; then
    iphone_se_firmware_select
fi
