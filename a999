#!/bin/bash

version=1.0.2
turdus_merula=turdus_m3rula-v1.0.4

echo -e "A999 Activator (A9, iOS 9, 9 years later) v$version\n(C) 2025 Alex Free (3-BSD)\nhttps://github.com/alex-free/a999activator\n"

cd "$(dirname "$0")"

# Global vars.
device=
ver=
serial=
not_normal=false
# This is for getting PTEBlock/SHCBlock/boot-* files from an existing downgraded iPhone.
regen_boot=false
# Forces no check for activation records, because well...
restore_ios_15=false
file=
# Untethered if not empty.
blob_generator=
blob_file=
use_blobs=

info_prompt() {
    case "$ver" in
        9.2*)
            echo "IMPORTANT INFORMATION FOR iOS 9.2 AND iOS 9.2.1 USERS (WHICH YOU ARE): DO NOT SIGN IN TO ICLOUD IN SETUP.APP! It will not work. Instead, complete Setup.app without signing in and get to the home screen. Then, sign in to iCloud with the Settings app!"
            ;;
        9.3*)
            echo "IMPORTANT INFORMATION FOR iOS 9.3, iOS 9.3.1, iOS 9.3.2, AND iOS 9.3.3 USERS (WHICH YOU ARE): iMessage and FaceTime do not work yet!"
            if [ $device != "iphone-se" ]; then
                echo "If you need iMessage and or FaceTime downgrade to iOS 9.2 or iOS 9.2.1 instead."
            fi
            ;;
    esac
}

# Note: this only does so much because it appears that if the iPhone was in DFU Mode and then exited it will auto-boot=true...
enforce_recovery() {
    Legacy-iOS-Kit/bin/macos/irecovery -c "setenv auto-boot false"
    Legacy-iOS-Kit/bin/macos/irecovery -c "saveenv"
}

pair_iphone() {
    while ! Legacy-iOS-Kit/bin/macos/idevicepair pair; do
        read -p "If your iPhone has a passcode, unlock your iPhone and then tap trust if prompted. If your not being prompted, unplug the USB-A to Lightning cable from your Mac then plug it back in. Then presss enter."
    done
}

iproxy_start() {
    Legacy-iOS-Kit/bin/macos/iproxy 6414 22 > /dev/null 2>&1 &
}

iproxy_kill() {
    killall iproxy > /dev/null 2>&1    
}

is_activated() {

    if Legacy-iOS-Kit/bin/macos/ideviceinfo | grep -q "^ActivationState: Activated$"; then
        return 0
    else
        return 1
    fi
}

restore_ios_15_for_device() {
    if [ $device == "iphone-6s-plus" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025WinterSeed/fullrestores/062-48382/6922D342-864E-4172-B8A2-D6293976E466/iPhone_5.5_15.8.4_19H390_Restore.ipsw
    elif [ $device == "iphone-6s" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025WinterSeed/fullrestores/062-48421/918618B0-E07D-479A-8F54-D61B7A426DCF/iPhone_4.7_15.8.4_19H390_Restore.ipsw
    elif [ $device == "iphone-se" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025WinterSeed/fullrestores/062-48461/D99373EA-9262-4602-A38A-5928DDA8D724/iPhone_4.0_64bit_15.8.4_19H390_Restore.ipsw
    fi
    
    wait_for_normal_mode
    echo "iOS 15.8.4 has been restored! It will take some additional time for it to start up into Setup.app, please wait..."
    pair_iphone
    
    read -p "* Activate the iPhone. IMPORTANT: If you are going to use cellular features on iOS 9, your SIM card should already be in in the iPhone with an active cell service before you activate it. 

* Sign in to iCloud and complete Setup.app. Get to the home screen. 

* Make sure Find My iPhone has been turned off.

After all of the above is true, press enter."

    wait_for_activation
}

boot_turdusra1n() {
    wait_for_recovery
    # Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus. It appears to be an issue with turdus merula because it won't show as much output (never gets to bootx) but still returns 0.
    while Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
        while ! $turdus_merula/bin/turdusra1n -TP data/$device-$serial/$ver/block/*-pteblock.bin; do 
        echo "Something went wrong, lets try that again."
        done

        # Give time to exit Recovery Mode so this is not executed again erronously.
        echo "Please wait, checking for proper booting in 20 seconds"
        sleep 20
    done

    wait_for_normal_mode
}

enter_recovery() {    
    if ! Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
        # If not in Recovery Mode assume in Normal Mode and attempt to enter Recovery Mode. If this fails we are already in Recovery Mode or possibly DFU Mode so we don't want to show an error."
        if Legacy-iOS-Kit/bin/macos/ideviceenterrecovery "$(Legacy-iOS-Kit/bin/macos/ideviceinfo -k UniqueDeviceID 2>/dev/null)" >/dev/null 2>&1; then
            # If this succeded lets tell the user what's going on. If it didn't succed then that's ok we don't need to tell them anything due to the above reasoning....
            echo "Entering Recovery Mode, please wait..."
        fi
        
        # If this was DFU Mode this is fine to show the user because it gets them back on track...
        wait_for_recovery
    fi
}

wait_for_normal_mode() {
    while ! Legacy-iOS-Kit/bin/macos/ideviceinfo >/dev/null 2>&1; do
        echo "Waiting for iPhone to boot..."
        sleep 1
    done
}

wait_for_recovery() {
     while ! Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
        if Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
            echo "DFU Mode detected. Please press the HOME+POWER buttons until your iPhone reboots into Recovery Mode. Do not stop pressing those buttons until you get to Recovery Mode."

            while Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "DFU Mode"; do
                sleep 1
            done

        fi

        echo "Expecting iPhone to be in Recovery Mode shortly, hang in there!"
        sleep 1
    done
    
    echo "Found iPhone in Recovery Mode!"
}

turdursra1n_pwn() {
    wait_for_recovery

    while ! $turdus_merula/bin/turdusra1n -ED; do
        echo "Something went wrong. Lets try that again..."
        sleep 1
    done
}

turdursra1n_pwn_blobs() {
    wait_for_recovery

    while ! $turdus_merula/bin/turdusra1n -EDb $blob_generator; do
        echo "Something went wrong. Lets try that again..."
        sleep 1
    done
}

retry_pwn() {
    echo "Something went wrong, lets try that again."
    turdursra1n_pwn
}

retry_pwn_blobs() {
    echo "Something went wrong, lets try that again."
    turdursra1n_pwn_blobs
}


start_rd() {
    # Enfore Recovery Mode.
    enter_recovery
    ssh_connected=0

    while [[ $ssh_connected != 1 ]]; do
        # Incase this failed previously and is running again, wait.
        wait_for_recovery
        # Stay in Recovery Mode, prevent normal mode booting until ramdisk boots and runs script to restore this. Unless we enter DFU mode accidentally this is the most useful case of enforce_recovery ever.
        enforce_recovery
        # Clear any existing iproxy...
        iproxy_kill
        # Attempt to boot ramdisk...
        (cd Legacy-iOS-Kit && ./restore.sh --no-version-check --no-internet-check --sshrd-boot-rd-only)
        # Start our own proxy for USB SSH fresh...
        iproxy_kill
        iproxy_start
        echo "Waiting 5 seconds before testing SSH ramdisk connection, please standby..."
        sleep 5
        # SSH connection check.
        ssh_connected=$(Legacy-iOS-Kit/bin/macos/sshpass -p 'alpine' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1 'echo 1' 2>/dev/null)
    done

    # Need to reset this for ramdisk round 2.
    ssh_connected=0

    echo "Booted SSH Ramdisk!"

    #ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
}

wait_for_activation()
{
    # This confirms the iPhone is activated. It does not confirm if iCloud was signed in, if Find My iPhone was turned off, or if an active cell service SIM was used during activation.
    while ! is_activated; do
        read -p "iPhone is not activated! Please make sure all of the above criteria are true as well and then press enter."
        sleep 1
    done
}

get_activation() {

    if [ ! -d data/$device-$serial/activate ]; then
        echo "Obtaining activation records..."
        restore_ios_15=false
        ios_version=$(Legacy-iOS-Kit/bin/macos/ideviceinfo 2>/dev/null | grep "ProductVersion" | awk '{print $2}')

        if [ "$not_normal" == "true" ]; then
            echo "Your iPhone is not in normal mode, so iOS version can not be determined. Restoring iPhone to iOS 15.8.4."
            restore_ios_15=true
        elif [ "$ios_version" != "15.8.4" ]; then
            echo "Latest iOS version is not installed. Restoring iPhone to iOS 15.8.4."
            restore_ios_15=true
        elif [ "$ios_version" == "15.8.4" ]; then
            pair_iphone
            read -p "Found iOS 15.8.4!

Because this is an existing iOS 15.8.4 installation, make sure all of the following is true:

* iPhone is activated. If you are going to use cellular features on iOS 9, your SIM card should have been in the iPhone when you originally activated it with an active cell service. 

* Setup.app has been previously been completed. Your iPhone should boot to the lockscreen, and go to the homescreen after being unlocked. It should not boot up to the hello screen (Setup.app).

* iCloud is signed in.

* Find My iPhone is turned off.

Do you need to restore your iPhone now to re-activate it with a SIM card installed that has an active cell service in order to use cellular features? (y/n): " restore_ios_15_response

            if [[ "$restore_ios_15_response" == "y" || "$restore_ios_15_response" == "Y" ]]; then
                restore_ios_15=true
            else
                # One last check to see if we should procceed on an existing iOS 15.8.4 installation.
                wait_for_activation
            fi
        fi

        if [ $restore_ios_15 == "true" ]; then
            restore_ios_15_for_device
        fi

        # Send it...
        start_rd
    else
        echo "Existing activation records found!"
        return
    fi

    expect <<EOF
    # Mount.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "mount_filesystems\r"
    expect "#"
    
    # Ramdisk allows RW of / on unjailbroken iOS 15.8.4. on /private/var we have stable RO. RW sometimes doesn't work, so use / as scratch dir.
    send "mkdir /mnt1/activate\r"
    expect "#"
    
    # Copy activation_records.
    send "cp -a /mnt2/containers/Data/System/*/Library/activation_records /mnt1/activate/activation_records\r"
    expect "#"

    # Copy data_ark.plist.
    send "cp -a /mnt2/containers/Data/System/*/Library/activation_records/../internal/data_ark.plist /mnt1/activate\r"
    expect "#"

    # Copy IC-Info.sisv for notifications/ft/imessage/etc
    send "cp -a /mnt2/mobile/Library/FairPlay/iTunes_Control/iTunes/IC-Info.sisv /mnt1/activate\r"
    expect "#"

    # Copy com.apple.commcenter.device_specific_nobackup.plist
    send "cp -a /mnt2/wireless/Library/Preferences/com.apple.commcenter.device_specific_nobackup.plist /mnt1/activate\r"
    expect "#"
    
    # Copy com.apple.factorydata
    send "cp -a /mnt1/System/Library/Caches/com.apple.factorydata /mnt1/activate/com.apple.factorydata\r"
    expect "#"

    # Create tars.
    send "cd /mnt1/activate\r"
    expect "#"
    
    # activation_records.
    send "tar zcf activation_records.tar.gz activation_records\r"
    expect "#"

    # data_ark.plist.
    send "tar zcf data_ark.plist.tar.gz data_ark.plist\r"
    expect "#"
    send "rm data_ark.plist\r"
    expect "#"
    
    # IC-Info.sisv. 
    # Silence error: "tar: copyfile pack (IC-Info.sisv) failed: No such file or directory" because we still get the file fine.
    send "tar zcf IC-Info.sisv.tar.gz IC-Info.sisv > /dev/null 2>&1\r"
    expect "#"
    send "rm IC-Info.sisv\r"
    expect "#"

    # com.apple.commcenter.device_specific_nobackup.plist.
    send "tar zcf com.apple.commcenter.device_specific_nobackup.plist.tar.gz com.apple.commcenter.device_specific_nobackup.plist\r"
    expect "#"
    send "rm com.apple.commcenter.device_specific_nobackup.plist\r"
    expect "#"

    # com.apple.factorydata.
    send "tar zcf com.apple.factorydata.tar.gz com.apple.factorydata\r"
    expect "#"

    # Delete all directories.
    send "rm -rf */\r"
    expect "#"

    send "exit\r"

    # Transfer tars to computer.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r -P 6414 root@127.0.0.1:/mnt1/activate data/$device-$serial/activate
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof  

    # Unmount and Reboot.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "reboot\r"
    expect "closed by remote host."
    expect eof
EOF

    iproxy_kill
}

restore_ipsw() {
    if [ $restore_ios_15 == "false" ]; then
        get_activation
    else
        restore_ios_15=false
    fi
    
    enter_recovery
    enforce_recovery

    # Check that we have ipsw file.
    file="$(basename $1)"

    if [ ! -f data/ipsw/$file ]; then
        echo "Downloading $file..."
        
        while ! curl -L $1 -o data/ipsw/$file; do
            echo "Download failed, trying again."
            rm $file
        done
    fi

    # Get ver and build number, i.e. 9.2_13D20 for possible iPhone 6S downgrade (even though we can't use 13D20 or any 'new' iOS 9.2.1 for other devices because jbme does not work)... Build number is important for iPhone 6S and iPhone 6S Plus which have 2 different iOS 9.2.1 versions available for restore.
    ver=$(echo "$file" | sed -E 's/.*_([0-9]+\.[0-9]+(\.[0-9]+)?)_([0-9A-Z]+)_Restore\.ipsw/\1_\3/')

    echo "Restoring iOS $ver with $file.."

    mkdir -p data/$device-$serial/$ver 

    #SHCblock.
    if ! find data/$device-$serial/$ver/block -type f -name "*-shcblock.bin" 2>/dev/null | grep -q . 2>/dev/null; then
        echo "Getting SHCBlock..."
        turdursra1n_pwn

        while ! echo 1 | $turdus_merula/bin/turdus_merula -C data/$device-$serial/$ver --get-shcblock data/ipsw/$file; do
            retry_pwn
        done

        wait_for_recovery
        enforce_recovery
    fi

    # PTEblock (Tethered ONLY).
    # If $use_blobs is empty then we are tethered.
    # If $use_blobs is false then we are going to do an untethered restore for the target iOS eventually, but we are currently doing tethered restores to get there (15.8.4, then 10.3.3).
    # If $use_blobs is empty and blob_file is empty then we are just doing a tethered restore without blobs.
    # If $use_blobs is true and $blob_file is not empty we are doing an untethered restore to the target iOS RIGHT NOW.
    if [ "$use_blobs" = "false" ] || [ -z "$blob_file" ]; then
        echo "Getting PTEBlock..."
        if ! find data/$device-$serial/$ver/block -type f -name "*-pteblock.bin" 2>/dev/null | grep -q . 2>/dev/null; then
            turdursra1n_pwn

            while ! echo 1 | $turdus_merula/bin/turdus_merula -C data/$device-$serial/$ver --get-pteblock --load-shcblock data/$device-$serial/$ver/block/*-shcblock.bin data/ipsw/$file; do
                retry_pwn
            done

            wait_for_recovery
            enforce_recovery
        fi
    fi

    echo "Restoring..."
    # Restore (Tethered).
    if [ "$use_blobs" = "false" ] || [ -z "$blob_file" ]; then
        turdursra1n_pwn
        
        while ! echo 1 | $turdus_merula/bin/turdus_merula -C data/$device-$serial/$ver -o --load-pteblock data/$device-$serial/$ver/block/*-pteblock.bin data/ipsw/$file; do
            retry_pwn
        done
    else
        # Restore (Untethered).
        turdursra1n_pwn_blobs

        while ! echo 1 | $turdus_merula/bin/turdus_merula -C data/$device-$serial/$ver -w --load-shsh $blob_file --load-shcblock data/$device-$serial/$ver/block/*-shcblock.bin data/ipsw/$file; do
            retry_pwn_blobs
        done
    fi
}

restore_10_3_3() {
    # We need to do this to prevent an issue where the device can crash randomly and enter DFU mode on the final restored firmware lower then 10.3.3. This also fixes a weird issue when you restore 9.3.x after being on 9.3.x, it can sometimes grey out the Wi-Fi.
    # When we end the activation get ramdisk we ALWAYS will be in Recovery Mode.
    if [ $device == "iphone-6s-plus" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23338-20170719-CA990FD6-6977-11E7-AE41-3B9100BA0AE3/iPhone_5.5_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone-6s" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23441-20170719-CA9B0570-6977-11E7-95CC-3F9100BA0AE3/iPhone_4.7_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone-se" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23133-20170719-CA8E78E6-6977-11E7-968B-2B9100BA0AE3/iPhone_4.0_64bit_10.3.3_14G60_Restore.ipsw
    fi

    # If set to false we have blobs for the target version.
    if [ "$use_blobs" = "false" ]; then
        use_blobs=true
    fi

    restore_ipsw $1

    # iPhone with blobs is going to boot into Normal Mode/Setup.app.
    if [ "$use_blobs" = "true" ]; then
        wait_for_normal_mode
        pair_iphone
    fi

    # Will enter Recovery if in normal mode for untether.
    start_rd

    expect <<EOF
    # Set up /.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "mount_hfs /dev/disk0s1s1 /mnt1\r"
    expect "#"
    send "mount_hfs /dev/disk0s1s2 /mnt2\r"
    expect "#"
    send "rm -rf /mnt1/activation\r"
    expect "#"
    send "mkdir /mnt1/Library/LaunchDaemons\r"
    expect "#"
    send "exit\r"

    # Transfer activation tars to phone.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r -P 6414 data/$device-$serial/activate root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer launch daemon com.alex.activate.plist to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 com.alex.activate.plist root@127.0.0.1:/mnt1/Library/LaunchDaemons
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer activate script to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 activate root@127.0.0.1:/mnt1/usr/bin
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer freeze.tar to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 Legacy-iOS-Kit/resources/jailbreak/freeze.tar root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer launchctl.tar to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 Legacy-iOS-Kit/resources/jailbreak/launchctl.tar root@127.0.0.1:/mnt1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer io.pangu93.loader.plist to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 Legacy-iOS-Kit/resources/jailbreak/io.pangu93.loader.plist root@127.0.0.1:/mnt1/Library/LaunchDaemons
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    # Transfer plutil (from com.bingner.plutil_0.2.1_iphoneos-arm.deb) to host.
    spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P 6414 plutil root@127.0.0.1:/mnt1/usr/bin/plutil
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }
    expect eof

    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"

    # Set permissions for activate.
    send "chmod 755 /mnt1/usr/bin/activate\r"
    expect "#"
    send "chown root:wheel /mnt1/usr/bin/activate\r"
    expect "#"

    # Set permissions for plutil.
    send "chmod 755 /mnt1/usr/bin/plutil\r"
    expect "#"
    send "chown root:wheel /mnt1/usr/bin/plutil\r"
    expect "#"

    # Install chflags from ramdisk
    send "cp -a /usr/bin/chflags /mnt1/usr/bin/chflags\r"
    expect "#"

    # Set permissions for launch daemon com.alex.activate.plist.
    expect "#"
    send "chmod 644 /mnt1/Library/LaunchDaemons/com.alex.activate.plist\r"
    expect "#"
    send "chown root:wheel /mnt1/Library/LaunchDaemons/com.alex.activate.plist\r"
    expect "#"
    
    # Move Setup.app to prevent possible deactivation causing it to trigger.
    send "mv /mnt1/Applications/Setup.app /mnt1/Applications/Setup.bak\r"
    expect "#"
    
    # BEGIN JAILBREAK BOOTSTRAP INSTALLATION.
    # Set permissions for launch daemon io.pangu93.loader.plist.
    send "chmod 644 /mnt1/Library/LaunchDaemons/io.pangu93.loader.plist \r"
    expect "#"
    send "chown root:wheel /mnt1/Library/LaunchDaemons/io.pangu93.loader.plist\r"
    expect "#"

    send "cd /mnt1\r"
    expect "#"

    # Extract freeze.tar.
    send "tar -xf freeze.tar -C .\r"
    expect "#"
    send "rm freeze.tar\r"
    expect "#"

    # Extract launchctl.tar.
    send "tar -xf launchctl.tar -C .\r"
    expect "#"
    send "rm launchctl.tar\r"
    expect "#"

    # Is this the symlink trick to write to /var?) 
    send "mv private/var/lib private\r"
    expect "#"
    send "mv private/var/mobile/Library/Preferences/com.apple.springboard.plist private\r"
    expect "#"
    send "rm -r private/var/*\r"
    expect "#"
    send "touch .cydia_no_stash\r"
    expect "#"
    send "cd /mnt2\r"
    expect "#"
    send "ln -s /private/lib\r"
    expect "#"
    send "cd mobile/Library/Preferences\r"
    expect "#"
    send "rm -f com.apple.springboard.plist\r"
    expect "#"
    send "ln -s /private/com.apple.springboard.plist\r"
    expect "#"
    send "chown 501:501 com.apple.springboard.plist\r"
    expect "#"
    send "exit\r"

    # Unmount and Reboot. Spawn a new session because symlink trick is weird and prevents unmounting /mnt2.
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 6414 root@127.0.0.1
    expect {
        "continue connecting" {
            send "yes\r"
            exp_continue
        }
        "password:" {
            send "alpine\r"
        }
    }

    expect "#"
    send "umount /mnt1\r"
    expect "#"
    send "umount /mnt2\r"
    expect "#"
    # This will only allow the SHSHBlob restored unthethered iPhone to boot to normal mode.
    send "nvram auto-boot=true\r"
    expect "#"
    send "reboot\r"
    expect "closed by remote host."
    expect eof
EOF

    iproxy_kill

    # Coming from a regular boot (untethered)
    if [ "$use_blobs" = true ]; then
        wait_for_normal_mode
        pair_iphone
         echo "Your iPhone is now jailbroken! You need to enable it now by visiting http://jbme.ddw.nu/ in Safari after signing in to your WiFi. Do not sign in to iCloud just yet! Once the jailbreak is enabled, your iPhone will automatically reboot and activation will be restored!"
        info_prompt
    else
        boot_turdusra1n
        pair_iphone
        echo "Your iPhone is now jailbroken! You need to enable it now by visiting http://jbme.ddw.nu/ in Safari after signing in to your WiFi. Once the jailbreak is enabled, your iPhone will automatically reboot into Recovery Mode after restoring activation. Do not sign in to iCloud just yet! a999activator is going to start checking for Recovery Mode in 30 seconds so that the LAST STEP can be completed!"
        sleep 30
        boot_turdusra1n

        if is_activated; then

            if [ $device == "iphone-6s-plus" ]; then
                boot_script=boot6sp-$ver-$serial
            elif [ $device == "iphone-6s" ]; then      
                boot_script=boot6s-$ver-$serial
            elif [ $device == "iphone-se" ]; then
                boot_script=bootse-$ver-$serial
            fi

            # Delete any existing boot* scripts for this serial number.
            rm -f *-$serial
            
            # Generate boot* script
    echo -e '#!/bin/bash

    cd "$(dirname "$0")"

    # Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus.
    while Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
        while ! '$turdus_merula'/bin/turdusra1n -TP data/'$device'-'$serial'/'$ver'/block/*-pteblock.bin; do 
            echo "Something went wrong, lets try that again..."
        done

        echo "Please wait, checking for proper booting in 20 seconds"
        sleep 20
    done
    echo "Enable the jailbreak with http://jbme.ddw.nu in Safari!"

    ' > $boot_script

            chmod 755 $boot_script
            # Clips the last character otherwise in the echo below.
            boot_script=$(echo "$boot_script" | tr -d '\r')
            echo "Activation was restored! You need to enable the jailbreak with http://jbme.ddw.nu in Safari everytime you boot, but your done! If your phone is powered off or rebooted, it will first boot to Recovery Mode. You'll need to run the $boot_script command (now found in the same folder as the a999 command) to boot it into normal mode."

            info_prompt
        else
            echo "Error: activation was not restored. Please try again."
            exit 1.
        fi
    fi
}

iphone_6s_firmware_select() {
    PS3="Select iOS version to downgrade to: "
    options=(
        "9.2 (13C75) (12/8/2015)"
        "9.2.1 (13D15) (1/19/2016)"
        #"9.2.1 (13D20) (2/18/2016)" Can't use because jbme doesn't support it
        "9.3 (13E234) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.2 (13C75) (12/8/2015)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.2.1/031-49377-20160217-4BB1908C-D44D-11E5-9900-0952919DCAD8/iPhone8,1_9.2.1_13D20_Restore.ipsw"
                break;
                ;;
            "9.2.1 (13D15) (1/19/2016)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.2.1/031-47635-20160119-97350056-B969-11E5-A65F-634D8FD31F8F/iPhone8,1_9.2.1_13D15_Restore.ipsw"
                break;
                ;;
            #"9.2.1 (13D20) (2/18/2016)") Can't use because jbme doesn't support it
                #restore_10_3_3 "http://appldnld.apple.com/ios9.2.1/031-49377-20160217-4BB1908C-D44D-11E5-9900-0952919DCAD8/iPhone8,1_9.2.1_13D20_Restore.ipsw"
                #break;
                #;;
            "9.3 (13E234) (3/21/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3/031-20814-20160321-50FF38D4-EAA8-11E5-AAA8-C479BD379832/iPhone8,1_9.3_13E234_Restore.ipsw"
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.1/031-55114-20160331-09A05894-F5E6-11E5-861F-21CB2D794EB1/iPhone8,1_9.3.1_13E238_Restore.ipsw"
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.3.2/031-62431-20160516-5E51F038-13A9-11E6-ACFA-61D9400DF7EB/iPhone8,1_9.3.2_13F69_Restore.ipsw"
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.3/031-60536-20160718-06EE469E-4378-11E6-8185-A7F759E0E9B6/iPhone8,1_9.3.3_13G34_Restore.ipsw"
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}


iphone_6s_plus_firmware_select() {

    PS3="Select iOS version to downgrade to: "
    options=(
        "9.2 (13C75) (12/8/2015)"
        "9.2.1 (13D15) (1/19/2016)"
        #"9.2.1 (13D20) (2/18/2016)" can't use because jbme doesn't support it
        "9.3 (13E234) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.2 (13C75) (12/8/2015)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.2/031-29142-20151203-53B314A8-8D8B-11E5-B7FA-9A638B8BECEB/iPhone8,2_9.2_13C75_Restore.ipsw"
                break;
                ;;
            "9.2.1 (13D15) (1/19/2016)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.2.1/031-47609-20160119-798F784C-B969-11E5-8729-F24C8FD31F8F/iPhone8,2_9.2.1_13D15_Restore.ipsw"
                break;
                ;;
            #"9.2.1 (13D20) (2/18/2016)") can't use because jbme doesn't support it
                #restore_10_3_3 "http://appldnld.apple.com/ios9.2.1/031-49073-20160217-4BB05046-D44D-11E5-9D30-0852919DCAD8/iPhone8,2_9.2.1_13D20_Restore.ipsw"
                #break;
                #;;
            "9.3 (13E234) (3/21/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3/031-28376-20160321-51006FEC-EAA8-11E5-AEC6-D279BD379832/iPhone8,2_9.3_13E234_Restore.ipsw"
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.1/031-54811-20160331-099896CC-F5E6-11E5-88BA-1ACB2D794EB1/iPhone8,2_9.3.1_13E238_Restore.ipsw"
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.3.2/031-62657-20160516-02ECC2F8-13AA-11E6-AFB3-D9DA400DF7EB/iPhone8,2_9.3.2_13F69_Restore.ipsw"
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.3/031-60985-20160718-5C7A1B06-4378-11E6-8743-CEFC59E0E9B6/iPhone8,2_9.3.3_13G34_Restore.ipsw"
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}

iphone_se_firmware_select() {

    PS3="Select iOS version to downgrade to: "
    options=(
        "9.3 (13E232) (3/21/2016)"
        "9.3.1 (13E238) (3/31/2016)"
        "9.3.2 (13F69) (5/16/2016)"
        "9.3.3 (13G34) (7/18/2016)"
        "Exit"
    )

    select opt in "${options[@]}"
    do
        case $opt in
            "9.3 (13E233) (3/21/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3/031-20815-20160321-5102B932-EAA8-11E5-A488-C779BD379832/iPhone8,4_9.3_13E233_Restore.ipsw"
                break;
                ;;
            "9.3.1 (13E238) (3/31/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.1/031-55507-20160331-09A917D6-F5E6-11E5-BFDA-32CB2D794EB1/iPhone8,4_9.3.1_13E238_Restore.ipsw"
                break;
                ;;
            "9.3.2 (13F69) (5/16/2016)")
                restore_10_3_3 "http://appldnld.apple.com/ios9.3.2/031-61688-20160516-6A0F5782-13A7-11E6-93C9-A4D6400DF7EB/iPhone8,4_9.3.2_13F69_Restore.ipsw"
                break;
                ;;
            "9.3.3 (13G34) (7/18/2016)")
                restore_10_3_3 "http://appldnld.apple.com/iOS9.3.3/031-60143-20160718-06E90A30-4378-11E6-81DC-8EF759E0E9B6/iPhone8,4_9.3.3_13G34_Restore.ipsw"
                break;
                ;;
            "Exit")
                break
                ;;
            *)
                echo "Invalid option"
                ;;
        esac
    done
}

# Begin actual execution. Check for the existence of the binary launch daemon which is generated for the release by the build script.
if [ ! -f "com.alex.activate.plist" ]; then
    echo "Error: can not find com.alex.activate.plist. This most likely means you are trying to execute a999 from the source tree, rather then a release which is not allowed. Please execute the build command in the source tree and cd into the built release. If you downloaded an a999activator release and are getting this error, you release is incomplete and missing a neccesary file. Please redownload the release and run a999activator again."
    exit 1
fi

# Update functionallity. We need to get 2 things, the data folder and any boot* scripts.

if [ "$1" == "-u" ]; then

    if [ "$#" -ne 2 ]; then
        echo "You gave the -u argument, which expect an existing a999activator release directory as the following argument."
        exit 1
    fi

    if [ -d "$2"/data ]; then
        echo "Found existing data folder!"
        cp -rv "$2"/data .
        echo "Copied existing data folder to a999activator!"
    else
        echo "Error: Could not find the data folder in $2!"
        exit 1
    fi

    # Don't print error messages if no boot-* files exist.
    cp -rv "$2"/boot-* . 2>/dev/null 
elif [ "$1" == "-b" ]; then
    # Get SHSH!
    if [ -f "$2" ]; then
        blob_file="$2"
        blob_generator=$(grep -A1 "<key>generator</key>" "$blob_file" | grep "<string>" | sed -E 's/.*<string>(.*)<\/string>.*/\1/'
)
        # By setting this to false we will restore possibly iOS 15.8.4 and iOS 10.3.3 tethered. Then right before the target version is restored we will set it to true by detecting it was set to false before. Always quote this when it could not be set to anything when checking.
        use_blobs=false
        echo "Untethered downgrade with blobs enabled! (Generator: $blob_generator)"
    else
        echo "Error: To use blobs for an untethered downgrade you must provide the .shsh file as the third argument! I.e. 

./a999 -b myblobs.shsh"
        exit 1
    fi
fi

if [ ! -d data ]; then
    echo "Creating data folder..."
else
    echo "Loaded existing data folder!"
fi

# Create ipsw directory if it does not exist.
mkdir -p data/ipsw

# Basically I handle the dependency stuff for Legacy-iOS-Kit right here and now. My fork of Legacy-iOS-Kit doesn't do this when ran because it makes the UX janky and it's much better to just do it here and now.
if [ -f ".firstrun" ]; then
    if command -v port > /dev/null; then
        echo "Found MacPorts!"
        sudo port -N install bash curl git libusb
        rm .firstrun
    elif command -v brew > /dev/null; then
        echo "Found Homebrew!"
        brew install bash curl git libusb
        rm .firstrun
    else
        echo "You need to install Homebrew or the MacPorts package manager."
        exit 1
    fi

    # This is to account for LibUSB being just installed.
    read -p "Please disconnect your USB-A Lightning cable from your mac, and then reconnect it"
fi

# All these executables are signed so that is the only think preventing gatekeeper from allowing the script to be automatic is the quarintine attributes.
# Remove any quarintine attribute on $turdus_merula
 xattr -rc $turdus_merula/bin
# Remove any quarintine attribute on Legacy-iOS-Kit.
xattr -rc Legacy-iOS-Kit/bin/macos

echo "Searching for an iPhone 6S, iPhone 6S Plus, or iPhone SE connected to this computer with a USB-A Lightning cable. Please wait..."

# Need the serial number to identify what cached data to use. This is available in Recovery Mode and Normal mode, but not in DFU Mode so we don't allow this to run until we get into Recovery Mode if DFU Mode is detected.
if Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
    wait_for_recovery
fi

# Loop until the iPhone can be detected in Recovery Mode or Normal Mode. It sure as hell aint in DFU Mode at this point...
while true; do

    if Legacy-iOS-Kit/bin/macos/irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
        echo "Info: iPhone was found in Recovery Mode."
        not_normal=true
        serial=$(Legacy-iOS-Kit/bin/macos/irecovery -q | grep -i 'SRNM:' | awk '{print $2}')

        if Legacy-iOS-Kit/bin/macos/irecovery -q |  grep '^PRODUCT: iPhone8,2'; then
            echo "iPhone 6S Plus detected!"
            device=iphone-6s-plus
        elif Legacy-iOS-Kit/bin/macos/irecovery -q | grep -q '^PRODUCT: iPhone8,1'; then
            echo "iPhone 6S detected!"
            device=iphone-6s
        elif Legacy-iOS-Kit/bin/macos/irecovery -q | grep -q '^PRODUCT: iPhone8,4'; then
            echo "iPhone SE detected!"
            device=iphone-se 
        else
            echo "Error: Currently only iPhone 6S, iPhone 6S Plus, and iPhone SE are supported! If you have a supported device, make sure it is connected with a Lightning to USB-A cable to this computer"
            exit 1
        fi

        if Legacy-iOS-Kit/bin/macos/irecovery -q | grep -q '^CPID: 0x8003'; then
            echo "Info: TSMC A9 chip detected!"
            break;
        elif Legacy-iOS-Kit/bin/macos/irecovery -q | grep -q '^CPID: 0x8001'; then
            echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
            break;
        elif Legacy-iOS-Kit/bin/macos/irecovery -q | grep -q '^CPID: 0x8000'; then
            echo "Info: Samsung A9 chip detected!"
            break;
        fi

    else
        pair_iphone
    
        serial=$(Legacy-iOS-Kit/bin/macos/ideviceinfo | grep -i '^SerialNumber:' | awk '{print $2}')
        
        if Legacy-iOS-Kit/bin/macos/ideviceinfo | grep -q '^ProductType: iPhone8,2' > /dev/null 2>&1; then
            echo "iPhone 6S Plus detected!"
            device=iphone-6s-plus
        elif Legacy-iOS-Kit/bin/macos/ideviceinfo | grep -q '^ProductType: iPhone8,1' > /dev/null 2>&1; then
            echo "iPhone 6S detected!"
            device=iphone-6s
        elif Legacy-iOS-Kit/bin/macos/ideviceinfo | grep -q '^ProductType: iPhone8,4' > /dev/null 2>&1; then
            echo "iPhone SE detected!"
            device=iphone-se
        else
            echo "Error: Currently only iPhone 6S, iPhone 6S Plus, and iPhone SE are supported! If you have a supported device, make sure it is connected with a Lightning to USB-A cable to this computer"
            exit 1
        fi

        if Legacy-iOS-Kit/bin/macos/ideviceinfo |  grep -q '^HardwarePlatform: s8003'; then
            echo "Info: TSMC A9 chip detected!"
            break;
        elif Legacy-iOS-Kit/bin/macos/ideviceinfo |  grep -q '^HardwarePlatform: s8001'; then
            echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
            break;
        elif Legacy-iOS-Kit/bin/macos/ideviceinfo |  grep -q '^HardwarePlatform: s8000'; then
            echo "Info: Samsung A9 chip detected!"
            break;
        fi
    fi
done

echo "Serial Number Identifier: $serial"

if [ $device == "iphone-6s-plus" ]; then
    iphone_6s_plus_firmware_select
elif [ $device == "iphone-6s" ]; then
    iphone_6s_firmware_select
elif [ $device == "iphone-se" ]; then
    iphone_se_firmware_select
fi
