pair_iphone(){
    idevicepair unpair >/dev/null 2>&1     
    idevicepair pair >/dev/null 2>&1
}

restore_signed_ios_for_device() {
    if [ $device == "iphone-6s-plus" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025FallFCS/fullrestores/082-67213/C471E1B8-CB73-4E02-8A9E-39166CD4FD28/iPhone_5.5_15.8.5_19H394_Restore.ipsw
    elif [ $device == "iphone-6s" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025FallFCS/fullrestores/082-67136/AC6F1095-935D-4892-9D11-84BE311843B4/iPhone_4.7_15.8.5_19H394_Restore.ipsw
    elif [ $device == "iphone-se" ]; then
        restore_ipsw https://updates.cdn-apple.com/2025FallFCS/fullrestores/082-66999/ECD8F46B-AF4B-454F-B6A4-55FEA09A10F9/iPhone_4.0_64bit_15.8.5_19H394_Restore.ipsw
    fi
    
    # Clean up.
    restore_signed_ios=false

    wait_for_normal_mode
    echo "iOS 15.8.5 has been restored! It will take some additional time for it to start up into Setup.app, please wait..."
 
    did_you_follow_instructions
}

detect_iphone() {
    # Fresh USB connection.
    usbmuxd_reset
    echo "Searching for an iPhone connected to this computer with a USB-A Lightning cable. Please wait..."

    # Need the serial number to identify what cached data to use. This is available in Recovery Mode and Normal mode, but not in DFU Mode so we don't allow this to run until we get into Recovery Mode if DFU Mode is detected.
    echo "Checking for iPhone in DFU Mode..."

    if irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
        wait_for_recovery
    fi

    # Loop until the iPhone can be detected in Recovery Mode or Normal Mode. It sure as hell aint in DFU Mode at this point...
    while true; do

        echo "Checking for iPhone in Recovery Mode..."

        if irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
            echo "Info: iPhone was found in Recovery Mode."
            not_normal=true
            serial=$(irecovery -q 2>/dev/null | grep -i 'SRNM:' | awk '{print $2}')

            if irecovery -q 2>/dev/null |  grep '^PRODUCT: iPhone8,2'; then
                echo "iPhone 6S Plus detected!"
                device=iphone-6s-plus
            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone8,1'; then
                echo "iPhone 6S detected!"
                device=iphone-6s
            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone8,4'; then
                echo "iPhone SE detected!"
                device=iphone-se 
            else
                echo "Error: Currently only iPhone 6S, iPhone 6S Plus, and iPhone SE are supported! If you have a supported device, make sure it is connected with a Lightning to USB-A cable to this computer"
                exit 1
            fi

            if irecovery -q 2>/dev/null | grep -q '^CPID: 0x8003'; then
                echo "Info: TSMC A9 chip detected!"
                break
            elif irecovery -q 2>/dev/null | grep -q '^CPID: 0x8001'; then
                echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
                break
            elif irecovery -q 2>/dev/null | grep -q '^CPID: 0x8000'; then
                echo "Info: Samsung A9 chip detected!"
                break
            fi

        else
            # Gets here if no iPhone is connected as well so set special arg.
            echo "Checking for iPhone in Normal Mode..."
            pair_iphone
            serial=$(ideviceinfo 2>/dev/null | grep -i '^SerialNumber:' | awk '{print $2}')
            
            if ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,2' > /dev/null 2>&1; then
                echo "iPhone 6S Plus detected!"
                device=iphone-6s-plus
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,1' > /dev/null 2>&1; then
                echo "iPhone 6S detected!"
                device=iphone-6s
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,4' > /dev/null 2>&1; then
                echo "iPhone SE detected!"
                device=iphone-se
            else
                echo "Error: currently only iPhone 6S, iPhone 6S Plus, and iPhone SE are supported! If you have a supported iPhone, make sure it is connected with a Lightning to USB-A cable to this computer and try again."
                exit 1
            fi

            if ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8003'; then
                echo "Info: TSMC A9 chip detected!"
                break
            elif ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8001'; then
                echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
                break
            elif ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8000'; then
                echo "Info: Samsung A9 chip detected!"
                break
            fi
        fi
    done

    if [ "$device" = "iphone-6s" ] || [ "$device" = "iphone-6s-plus" ] || [ "$device" = "iphone-se" ]; then
        a9=true
    fi

    echo "Serial Number Identifier: $serial"
}

# Trick lifted from https://docs.website-msw.pages.dev/docs/get-started/installing-palera1n-linux/.
usbmuxd_reset() {
    if [ "$os" == "Linux" ]; then
        systemctl stop usbmuxd > /dev/null 2>&1
        # If usbmuxd is still running kill it forcibly.
        killall -9 usbmuxd > /dev/null 2>&1
        usbmuxd -f -p & > /dev/null 2>&1
    fi
}

# Note: this only does so much because it appears that if the iPhone was in DFU Mode and then exited it will auto-boot=true.
enforce_recovery() {
    irecovery -c "setenv auto-boot false"
    irecovery -c "saveenv"
}

boot_turdusra1n() {
    wait_for_recovery

    # Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus. It appears to be an issue with turdus merula because it won't show as much output (never gets to bootx) but still returns 0.
    while irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
        echo "Info: If you get an error about failed to open handle (no device) after Checkmate?, disconnect then reconnect your iPhone."
        usbmuxd_reset
        
        if [ "$a9" = "true" ]; then
        
            while ! turdusra1n -TP data/$device-$serial/$ver/block/*-pteblock2.bin; do
                usbmuxd_reset
                echo "Something went wrong, lets try that again."
            done
        else
            while ! turdusra1n -t data/$device-$serial/$ver/img4/*iBoot.img4 -i data/$device-$serial/$ver/img4/*signed-SEP.img4 -p data/$device-$serial/$ver/img4/*target-SEP.im4p; do
                usbmuxd_reset
                echo "Something went wrong, lets try that again."
            done
        fi
        # Give time to exit Recovery Mode so this is not executed again erronously.
        echo "Please wait, checking for proper booting in 20 seconds"
        sleep 20
    done
}

enter_recovery() {    
    if ! irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
        # If not in Recovery Mode assume in Normal Mode and attempt to enter Recovery Mode. If this fails we are already in Recovery Mode or possibly DFU Mode so we don't want to show an error."
        if ideviceenterrecovery "$(ideviceinfo -k UniqueDeviceID 2>/dev/null)" >/dev/null 2>&1; then
            # If this succeded lets tell the user what's going on. If it didn't succed then that's ok we don't need to tell them anything due to the above reasoning....
            echo "Entering Recovery Mode, please wait..."
        fi
        
        # If this was DFU Mode this is fine to show the user because it gets them back on track...
        wait_for_recovery
    fi
}

wait_for_normal_mode() {
    echo "Waiting for iPhone to boot into Normal Mode..."

    while ! ideviceinfo 2>/dev/null; do
       # Ensure we are paired, fixes issues when booting iOS 9.
        pair_iphone
        sleep 1
    done
}

wait_for_recovery() {
    echo "Expecting iPhone to be in Recovery Mode shortly, hang in there!"

     while ! irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do

        if irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
            echo "DFU Mode detected. Please press the HOME+POWER buttons until your iPhone reboots into Recovery Mode. Do not stop pressing those buttons until you get to Recovery Mode."

            while irecovery -m 2>/dev/null | grep -q "DFU Mode"; do
                sleep 1
            done

        fi

        sleep 1
    done
    
    echo "Found iPhone in Recovery Mode!"
}

turdursra1n_pwn() {
    wait_for_recovery
    usbmuxd_reset

    while ! turdusra1n -D; do
        echo "Something went wrong. Lets try that again..."
        sleep 1
    done
}

retry_pwn() {
    echo "Something went wrong, lets try that again."
    turdursra1n_pwn
}

restore_ipsw() {
    enter_recovery
    enforce_recovery

    # If given URL, using a999activator setup with hardcoded URLs.
    if [[ "$1" == http://* || "$1" == https://* ]]; then
        mkdir -p data/ipsw
        # Check that we have ipsw file.
        ipsw_file="data/ipsw/$(basename "$1")"

        if [ ! -f $ipsw_file ]; then
            echo "Downloading $ipsw_file..."
            
            while ! curl -L $1 -o $ipsw_file; do
                echo "Download failed, trying again."
                rm -f $ipsw_file
            done
        fi
    elif [ -f "$1" ]; then
        ipsw_file="$1"
    fi

    # Get ver and build number, i.e. 9.2_13D20 for possible iPhone 6S downgrade (even though we can't use 13D20 or any 'new' iOS 9.2.1 for other devices because jbme does not work)... Build number is important for iPhone 6S and iPhone 6S Plus which have 2 different iOS 9.2.1 versions available for restore.
    ver=$(echo "$ipsw_file" | sed -E 's/.*_(.*_.*)_Restore\.ipsw/\1/')

    echo "Restoring iOS $ver with $ipsw_file.."

    mkdir -p data/$device-$serial/$ver 

    if [ "$a9" = "true" ]; then
        #SHCblock.
        # BUG (in turdus_merula since v1.1). This can exit ok but it really didn't get the PTE block so we need to check again even after it returns 0. This is done for SHCBlock just in case the same could happen (trust issues since PTEBlock surfaced).
        while ! find data/$device-$serial/$ver/block -type f -name "*restore-shcblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting restore SHCBlock..."
            turdursra1n_pwn

            while ! echo 1 | turdus_merula -C data/$device-$serial/$ver --get-shcblock $ipsw_file; do
                retry_pwn
            done

            wait_for_recovery
            enforce_recovery
        done

        echo "Restoring..."
        # Restore.
        turdursra1n_pwn

        while ! echo 1 | turdus_merula -C data/$device-$serial/$ver -o --load-shcblock data/$device-$serial/$ver/block/*-restore-shcblock2.bin $ipsw_file; do
            retry_pwn
        done

        # Skip the rest if signed ios ver or if intermediete restore (i.e. 10.3.3 before 10.0-10.3.2, or 10.2.1 before 9.x).
        if [ "$not_final_restore" = "true" ]; then
            return
        fi

        while ! find data/$device-$serial/$ver/block -type f -name "*-current-shcblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting post-restore SHCBlock..."
            cd data/$device-$serial/$ver
            mkdir -p block

            while ! turdusra1n -g $ipsw_file; do
                echo "Something went wrong, let's try that again..."
            done

            cd ../../../

            wait_for_recovery
            enforce_recovery
        done

        # Get PTEBlock.
        while ! find data/$device-$serial/$ver/block -type f -name "*-pteblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting PTEBlock..."
            cd data/$device-$serial/$ver
            mkdir -p block
            
            while ! turdusra1n -g -i image4/*signed-SEP.img4 -C block/*-current-shcblock2.bin $ipsw_file; do
                echo "Something went wrong, let's try that again..."
            done

            cd ../../../
            wait_for_recovery
            enforce_recovery
        done
    else
        echo "Restoring..."
        # Restore.
        turdursra1n_pwn

        while ! echo 1 | turdus_merula -C data/$device-$serial/$ver -o $ipsw_file; do
            retry_pwn
        done
    fi
}

restore_ios_10_2_1_for_device() {
    # We need to do this to prevent an issue where the device can crash randomly and enter DFU mode on the final restored firmware lower then 10.2.1. This also fixes a weird issue when you restore 9.3.x after being on 9.3.x, it can sometimes grey out the Wi-Fi. This was originally 10.2.1, but due to an issue with restoring/booting the ramdisk this now is 10.2.1 (which is HFS+) https://www.reddit.com/r/LegacyJailbreak/comments/1nj598d/issue_downgrading_a9_devices_to_ios_9x_using/.
    # When we end the activation get ramdisk we ALWAYS will be in Recovery Mode.
    if [ $device == "iphone-6s-plus" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.2.1/031-96800-20170112-6151CD56-D81D-11E6-A447-F501D55B5B9D/iPhone_5.5_10.2.1_14D27_Restore.ipsw
    elif [ $device == "iphone-6s" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.2.1/031-96803-20170112-6151BFBE-D81D-11E6-8553-F701D55B5B9D/iPhone_4.7_10.2.1_14D27_Restore.ipsw
    elif [ $device == "iphone-se" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.2.1/031-96769-20170112-61558B4E-D81D-11E6-9610-F301D55B5B9D/iPhoneSE_10.2.1_14D27_Restore.ipsw
    fi

}